# iptables and nftables — Linux Firewall

> Every Linux server on the internet is constantly being scanned, probed, and attacked. The firewall is your first line of defense. iptables has been the Linux firewall for 20+ years; nftables is its modern replacement. Understanding both is essential — you'll encounter iptables in legacy systems and nftables in modern deployments.

---

## Table of Contents

1. [Linux Firewall Architecture (Netfilter)](#netfilter)
2. [iptables Fundamentals](#iptables-fundamentals)
3. [iptables Tables and Chains](#tables-chains)
4. [Writing iptables Rules](#writing-rules)
5. [Common iptables Configurations](#common-configs)
6. [nftables — The Modern Replacement](#nftables)
7. [nftables Syntax and Rules](#nftables-rules)
8. [Stateful Firewalling](#stateful)
9. [Firewall Best Practices](#best-practices)
10. [Debugging Firewall Rules](#debugging)
11. [Key Takeaways](#key-takeaways)

---

## Netfilter

Both iptables and nftables are frontends to **Netfilter** — the packet filtering framework built into the Linux kernel:

```
                    ┌─────────────────────────────────────────┐
                    │           Linux Kernel (Netfilter)       │
                    │                                         │
                    │  PREROUTING → ROUTING → FORWARD → POSTROUTING
                    │      │        DECISION     │           │
                    │      │           │          │           │
                    │      │        INPUT      OUTPUT         │
                    │      │           │          │           │
                    │      │        ┌──▼──┐    ┌──┘           │
                    │      │        │ Local│    │              │
                    │      │        │Process│   │              │
                    │      │        └──────┘   │              │
                    └──────┼──────────────────┼──────────────┘
                           │                  │
User-space tools:    iptables / nftables (configure rules)
```

### Hook points (where packets can be intercepted)

| Hook | When |
|------|------|
| **PREROUTING** | Packet arrives, BEFORE routing decision |
| **INPUT** | Packet destined for THIS machine |
| **FORWARD** | Packet passing THROUGH this machine (routing) |
| **OUTPUT** | Packet generated BY this machine |
| **POSTROUTING** | Packet leaving, AFTER routing decision |

### Packet flow

```
Incoming packet for this machine:
  PREROUTING → INPUT → Local Process

Packet being forwarded (router):
  PREROUTING → FORWARD → POSTROUTING

Outgoing packet from this machine:
  Local Process → OUTPUT → POSTROUTING
```

---

## iptables Fundamentals

### Core concepts

```
Table:  Group of chains with a specific purpose
Chain:  Ordered list of rules
Rule:   Match criteria + action (target)
Target: What to do with matched packet (ACCEPT, DROP, REJECT, LOG, etc.)
```

### Rule evaluation

```
Packet enters chain:
  Rule 1: Match? → No  → next rule
  Rule 2: Match? → No  → next rule
  Rule 3: Match? → Yes → execute target (ACCEPT/DROP/etc.)
  
  If NO rule matches → chain's DEFAULT POLICY applies
  (typically ACCEPT or DROP)
```

---

## Tables and Chains

### iptables has 5 tables

| Table | Purpose | Built-in Chains |
|-------|---------|-----------------|
| **filter** | Packet filtering (firewalling) — DEFAULT | INPUT, FORWARD, OUTPUT |
| **nat** | Network Address Translation | PREROUTING, OUTPUT, POSTROUTING |
| **mangle** | Packet modification (ToS, TTL, etc.) | All 5 hooks |
| **raw** | Skip connection tracking | PREROUTING, OUTPUT |
| **security** | SELinux marking | INPUT, OUTPUT, FORWARD |

```
Most common: filter (firewall rules) and nat (NAT/port forwarding)
```

### Processing order

```
Incoming packet:
  raw PREROUTING → mangle PREROUTING → nat PREROUTING →
  mangle INPUT → filter INPUT → security INPUT → Local Process

Forwarded packet:
  raw PREROUTING → mangle PREROUTING → nat PREROUTING →
  mangle FORWARD → filter FORWARD → security FORWARD →
  mangle POSTROUTING → nat POSTROUTING

Outgoing packet:
  raw OUTPUT → mangle OUTPUT → nat OUTPUT → filter OUTPUT →
  security OUTPUT → mangle POSTROUTING → nat POSTROUTING
```

---

## Writing Rules

### Basic syntax

```bash
iptables [-t table] -A CHAIN [match criteria] -j TARGET

-t table:    filter (default), nat, mangle, raw
-A CHAIN:    Append to INPUT, FORWARD, OUTPUT, etc.
-j TARGET:   ACCEPT, DROP, REJECT, LOG, RETURN, etc.

Match criteria:
  -p proto    Protocol (tcp, udp, icmp)
  -s source   Source IP/CIDR
  -d dest     Destination IP/CIDR
  --sport     Source port
  --dport     Destination port
  -i iface    Input interface
  -o oface    Output interface
  -m module   Extension module (state, multiport, conntrack, etc.)
```

### Targets

```
ACCEPT:  Allow packet through
DROP:    Silently discard (sender gets no response)
REJECT:  Discard + send ICMP error (sender knows it was rejected)
LOG:     Log to syslog, then continue to next rule
RETURN:  Return to calling chain (for user-defined chains)

DROP vs REJECT:
  DROP:   Attacker doesn't know if host exists (stealth)
          But: legitimate users experience timeouts instead of errors
  REJECT: Sender learns it was rejected (faster failure)
          But: confirms host exists to attackers
  
  Best practice: DROP from internet, REJECT from internal network
```

### Examples

```bash
# Allow SSH
iptables -A INPUT -p tcp --dport 22 -j ACCEPT

# Allow HTTP and HTTPS
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -j ACCEPT

# Allow established connections (critical for stateful firewall)
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Allow localhost
iptables -A INPUT -i lo -j ACCEPT

# Allow ping
iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT

# Drop everything else (default policy)
iptables -P INPUT DROP

# Allow specific IP
iptables -A INPUT -s 203.0.113.0/24 -p tcp --dport 22 -j ACCEPT

# Block specific IP
iptables -A INPUT -s 198.51.100.42 -j DROP

# Rate limit SSH (prevent brute force)
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW \
         -m recent --set --name SSH
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW \
         -m recent --update --seconds 60 --hitcount 4 --name SSH -j DROP

# Log dropped packets
iptables -A INPUT -j LOG --log-prefix "IPTABLES-DROP: " --log-level 4
iptables -A INPUT -j DROP
```

### Managing rules

```bash
# List rules (with line numbers)
iptables -L -n -v --line-numbers
iptables -t nat -L -n -v

# Delete rule by number
iptables -D INPUT 3

# Delete rule by specification
iptables -D INPUT -p tcp --dport 80 -j ACCEPT

# Insert rule at position (before other rules)
iptables -I INPUT 1 -p tcp --dport 22 -j ACCEPT

# Flush all rules (warning: may lock you out!)
iptables -F

# Reset to default (accept everything)
iptables -P INPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -P OUTPUT ACCEPT
iptables -F

# Save rules (persist across reboots)
iptables-save > /etc/iptables/rules.v4
# Restore
iptables-restore < /etc/iptables/rules.v4

# On Debian/Ubuntu:
apt install iptables-persistent
netfilter-persistent save
```

---

## Common Configurations

### Basic server firewall

```bash
#!/bin/bash
# Flush existing rules
iptables -F
iptables -X

# Default policies: drop incoming, allow outgoing
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# Allow loopback
iptables -A INPUT -i lo -j ACCEPT

# Allow established and related connections
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

# Allow SSH (restrict to specific IP if possible)
iptables -A INPUT -p tcp --dport 22 -j ACCEPT

# Allow HTTP/HTTPS
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -j ACCEPT

# Allow ping (optional)
iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT

# Log and drop everything else
iptables -A INPUT -j LOG --log-prefix "DROPPED: " --log-level 4
iptables -A INPUT -j DROP

# Save
iptables-save > /etc/iptables/rules.v4
```

### SYN flood protection

```bash
# Limit new TCP connections (SYN packets)
iptables -A INPUT -p tcp --syn -m connlimit --connlimit-above 20 -j DROP

# Enable SYN cookies (kernel-level, more effective)
echo 1 > /proc/sys/net/ipv4/tcp_syncookies
```

### Port knocking (security through obscurity + defense in depth)

```bash
# SSH only accessible after "knocking" on ports 7000, 8000, 9000 in sequence
# (Implemented with iptables recent module — concept demonstration)
# In practice, use fwknop (Single Packet Authorization) instead
```

---

## nftables

### Why nftables replaces iptables

```
iptables problems:
  - Separate tools: iptables, ip6tables, arptables, ebtables
  - Complex syntax for advanced rules
  - Rule updates replace entire chain (atomic but slow)
  - Limited table/chain structure (can't create new tables freely)

nftables advantages:
  - One tool for IPv4, IPv6, ARP, bridge filtering
  - Cleaner syntax
  - Built-in sets and maps (replace ipset)
  - Atomic rule replacement
  - Better performance (new kernel virtual machine)
  - More flexible (create custom tables and chains)
```

### nftables status (2024)

```
Debian 10+: nftables default backend (iptables commands still work via compat layer)
RHEL 8+/CentOS 8+: nftables default
Ubuntu 20.04+: nftables available, iptables still works

The iptables-nft tool translates iptables commands to nftables internally.
If you run iptables on modern distros, you may actually be using nftables!

Check: iptables --version
  iptables v1.8.7 (nf_tables)  ← using nftables backend!
  iptables v1.8.7 (legacy)     ← using legacy iptables
```

---

## nftables Rules

### Basic structure

```bash
# Create table
nft add table inet myfilter    # inet = IPv4 + IPv6

# Create chain
nft add chain inet myfilter input {
    type filter hook input priority 0 \;
    policy drop \;
}

# Add rules
nft add rule inet myfilter input iif lo accept
nft add rule inet myfilter input ct state established,related accept
nft add rule inet myfilter input tcp dport 22 accept
nft add rule inet myfilter input tcp dport { 80, 443 } accept
nft add rule inet myfilter input icmp type echo-request accept
nft add rule inet myfilter input counter log prefix "DROPPED: " drop
```

### Complete server firewall (nftables)

```bash
#!/usr/sbin/nft -f

flush ruleset

table inet firewall {
    chain input {
        type filter hook input priority 0; policy drop;
        
        # Loopback
        iif lo accept
        
        # Established connections
        ct state established,related accept
        
        # Invalid packets
        ct state invalid drop
        
        # ICMP (ping)
        ip protocol icmp accept
        ip6 nexthdr icmpv6 accept
        
        # SSH
        tcp dport 22 accept
        
        # HTTP/HTTPS
        tcp dport { 80, 443 } accept
        
        # Log and drop
        counter log prefix "nft-drop: " drop
    }
    
    chain forward {
        type filter hook forward priority 0; policy drop;
    }
    
    chain output {
        type filter hook output priority 0; policy accept;
    }
}
```

### nftables features iptables lacks

```bash
# Sets — match against a set of values
nft add set inet firewall blocked_ips { type ipv4_addr \; }
nft add element inet firewall blocked_ips { 198.51.100.1, 198.51.100.2, 203.0.113.0/24 }
nft add rule inet firewall input ip saddr @blocked_ips drop

# Named sets with timeout (auto-expire entries)
nft add set inet firewall recent_ssh { type ipv4_addr \; timeout 5m \; }

# Maps — translate values
nft add map inet firewall port_redirect { type inet_service : inet_service \; }
nft add element inet firewall port_redirect { 8080 : 80, 8443 : 443 }

# Meters — rate limiting
nft add rule inet firewall input tcp dport 22 \
    meter ssh_limit { ip saddr limit rate 3/minute } accept
nft add rule inet firewall input tcp dport 22 drop

# Concatenations — match on multiple fields
nft add set inet firewall allowlist {
    type ipv4_addr . inet_service \;
}
nft add element inet firewall allowlist { 10.0.0.5 . 22 }
nft add rule inet firewall input ip saddr . tcp dport @allowlist accept
```

### Managing nftables

```bash
# List all rules
nft list ruleset

# List specific table
nft list table inet firewall

# Delete rule (by handle number)
nft -a list chain inet firewall input    # show handles
nft delete rule inet firewall input handle 7

# Save/restore
nft list ruleset > /etc/nftables.conf
# Load on boot: systemctl enable nftables

# Atomic replacement (all rules at once)
nft -f /etc/nftables.conf
```

---

## Stateful Firewalling

### Why stateful matters

```
Stateless firewall (just IP/port matching):
  Allow port 80 inbound → allows web traffic ✓
  But also allows attacker to send ANY packet to port 80!
  
  Allow port 80 outbound → web server can respond ✓
  But what about return traffic from connections WE initiated?
  Must allow ALL high ports inbound → security hole!

Stateful firewall (tracks connections):
  Allow NEW connections to port 80 inbound ✓
  Allow ESTABLISHED connections in any direction ✓
  Drop anything that doesn't match a tracked connection ✗
```

### Connection tracking states

```
NEW:         First packet of a connection (SYN for TCP)
ESTABLISHED: Part of an already-established connection
RELATED:     Related to an established connection (ICMP error, FTP data)
INVALID:     Doesn't belong to any known connection (should DROP)
UNTRACKED:   Explicitly excluded from tracking (raw table)
```

### The golden rule of stateful firewalling

```bash
# ALWAYS include this rule early in your INPUT chain:
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
# or nftables:
ct state established,related accept

# This allows:
# - Response to YOUR outbound connections (apt update, curl, DNS)
# - ICMP errors related to your connections
# - FTP data connections related to FTP control connections

# Then DROP INVALID:
iptables -A INPUT -m conntrack --ctstate INVALID -j DROP
```

---

## Firewall Best Practices

### Defense in depth

```
1. Default deny: Set policy to DROP, explicitly allow needed traffic
2. Least privilege: Only open ports that MUST be open
3. Stateful: Use connection tracking (ESTABLISHED,RELATED)
4. Drop INVALID: Always drop packets that don't match any connection
5. Rate limit: Protect against brute force and DoS
6. Log before drop: Log dropped packets for forensics (but rate-limit logs!)
7. Restrict by source: If only office IPs need SSH, restrict to those IPs
8. Outbound filtering: Consider restricting outbound too (exfiltration prevention)
```

### Rule ordering

```
Order matters! Rules evaluated top-to-bottom, first match wins.

Good order:
  1. Allow loopback (lo interface)
  2. Allow established/related connections
  3. Drop invalid connections
  4. Allow specific services (SSH, HTTP, HTTPS)
  5. Rate limiting rules
  6. Log
  7. Default drop (policy or explicit rule)

Bad order:
  1. Drop all ← Everything dropped, rules below never reached!
  2. Allow SSH ← Never evaluated!
```

### Don't lock yourself out!

```bash
# When configuring firewall remotely (SSH):

# Option 1: Scheduled reset
at now + 5 minutes <<< "iptables -P INPUT ACCEPT && iptables -F"
# If you get locked out, rules reset in 5 minutes

# Option 2: Test before commit
iptables-apply /etc/iptables/rules.v4
# Prompts "Are the new rules working? [y/N]"
# Auto-reverts after 10 seconds if you don't confirm (locked out = auto-revert)

# Option 3: Always ensure SSH rule is first
iptables -I INPUT 1 -p tcp --dport 22 -s YOUR_IP -j ACCEPT
```

---

## Debugging

### Packet tracing

```bash
# Enable TRACE for specific packets in iptables
iptables -t raw -A PREROUTING -p tcp --dport 80 -j TRACE
iptables -t raw -A OUTPUT -p tcp --dport 80 -j TRACE
# View trace: dmesg or /var/log/kern.log
# Shows which table/chain/rule each packet hits

# nftables tracing
nft add rule inet firewall input meta nftrace set 1
nft monitor trace

# Watch packet counters in real-time
watch -n1 "iptables -L -n -v"
watch -n1 "nft list chain inet firewall input"
```

### Checking if firewall is the problem

```bash
# Temporarily accept all (CAREFUL: only on non-production)
iptables -P INPUT ACCEPT && iptables -F
# Test connectivity
# If it works → firewall was blocking

# Check if specific port is filtered
nmap -p 80 target_ip
# "filtered" = firewall dropping
# "closed"   = port not listening (no firewall issue)

# Check from the server itself
ss -tulnp | grep :80     # Is something listening?
iptables -L -n -v | grep 80  # Is firewall allowing?

# Check log for drops
grep "DROPPED\|nft-drop" /var/log/syslog | tail -20
dmesg | grep "DROPPED\|nft-drop" | tail -20
```

### Common mistakes

```
1. Forgetting ESTABLISHED,RELATED rule → outbound connections can't get responses
2. Blocking ICMP entirely → breaks path MTU discovery, debugging tools
3. Not saving rules → reboot clears firewall (wide open!)
4. Rule order wrong → more specific rules after generic rules
5. Forgetting IPv6 → iptables only filters IPv4, need ip6tables too
   (nftables: use 'inet' family to handle both)
```

---

## Key Takeaways

1. **Netfilter** is the kernel framework; iptables/nftables are user-space tools to configure it
2. **Five hook points**: PREROUTING, INPUT, FORWARD, OUTPUT, POSTROUTING
3. **Default deny**: Set INPUT policy to DROP, explicitly allow needed services
4. **Stateful firewalling** with conntrack: Always allow ESTABLISHED,RELATED early in your chain
5. **DROP vs REJECT**: DROP is stealthier (no response); REJECT sends ICMP error (faster failure)
6. **nftables replaces iptables** — cleaner syntax, sets, maps, single tool for IPv4/IPv6
7. **Rule order matters**: First match wins; put specific rules before generic ones
8. **Don't lock yourself out**: Use `at` scheduled reset or `iptables-apply` when configuring remotely
9. **Persist rules**: `iptables-save` / `netfilter-persistent` for iptables; `/etc/nftables.conf` for nftables
10. **Debug with tracing**: iptables TRACE target or nftables `meta nftrace set 1` + `nft monitor trace`

---

## Next

→ [03-connection-tracking.md](03-connection-tracking.md) — Conntrack: the stateful engine behind Linux firewalling and NAT
